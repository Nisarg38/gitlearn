# gitlearn - Learn from merged PRs and keep AI context files fresh
# https://github.com/Nisarg38/gitlearn
#
# Setup:
#   mkdir -p .github/workflows && curl -o .github/workflows/gitlearn.yml https://raw.githubusercontent.com/Nisarg38/gitlearn/main/.github/workflows/gitlearn.yml
#   gh secret set ANTHROPIC_API_KEY  # or OPENAI_API_KEY, OPENROUTER_API_KEY
#
# Default models:
#   Anthropic: claude-sonnet-4-5-20250929 (extended thinking)
#   OpenAI: gpt-5.2-codex
#   OpenRouter: moonshotai/kimi-k2.5

name: gitlearn

on:
  # Weekly schedule - runs every Monday at 9am UTC (processes all merged PRs from the past week)
  schedule:
    - cron: '0 9 * * 1'
  # Manual trigger for on-demand runs
  workflow_dispatch:
  # Per-PR trigger (optional - disable by setting GITLEARN_TRIGGER_MODE to 'weekly')
  pull_request:
    types: [closed]
    branches: [main, master]

jobs:
  learn:
    if: |
      github.event_name == 'schedule' ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true && vars.GITLEARN_TRIGGER_MODE != 'weekly')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
      GITLEARN_MODEL: ${{ vars.GITLEARN_MODEL }}
      GITLEARN_MAX_TOKENS: ${{ vars.GITLEARN_MAX_TOKENS }}
      GITLEARN_THINKING_BUDGET: ${{ vars.GITLEARN_THINKING_BUDGET }}
      GITLEARN_API_BASE: ${{ vars.GITLEARN_API_BASE }}
      GITLEARN_SKIP_LABELS: ${{ vars.GITLEARN_SKIP_LABELS }}
      GITLEARN_REVIEWER: ${{ vars.GITLEARN_REVIEWER }}
      GITLEARN_TRIGGER_MODE: ${{ vars.GITLEARN_TRIGGER_MODE }}

    steps:
      - name: Check skip labels
        id: skip
        run: |
          # Skip label check only applies to pull_request events
          if [ "${{ github.event_name }}" != "pull_request" ]; then
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          SKIP_LABELS="${GITLEARN_SKIP_LABELS:-dependencies,chore}"
          PR_LABELS='${{ toJson(github.event.pull_request.labels.*.name) }}'
          for label in ${SKIP_LABELS//,/ }; do
            if echo "$PR_LABELS" | grep -qi "\"$label\""; then
              echo "skip=true" >> $GITHUB_OUTPUT
              echo "### ‚è≠Ô∏è gitlearn" >> $GITHUB_STEP_SUMMARY
              echo "Skipped - PR has label: $label" >> $GITHUB_STEP_SUMMARY
              exit 0
            fi
          done
          echo "skip=false" >> $GITHUB_OUTPUT

      - uses: actions/checkout@v4
        if: steps.skip.outputs.skip != 'true'
        with:
          fetch-depth: 0

      - name: Collect merged PRs (scheduled run)
        if: steps.skip.outputs.skip != 'true' && github.event_name != 'pull_request'
        id: collect
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get merged PRs from the past 7 days
          SINCE=$(date -d '7 days ago' -Iseconds 2>/dev/null || date -v-7d -Iseconds)
          SKIP_LABELS="${GITLEARN_SKIP_LABELS:-dependencies,chore}"

          echo "Collecting merged PRs since $SINCE..."

          # Get merged PRs, filter out skipped labels
          PRS=$(gh pr list --state merged --search "merged:>=$SINCE" --json number,title,body,labels --limit 50)

          # Filter out PRs with skip labels
          FILTERED_PRS=$(echo "$PRS" | jq -c --arg skip "$SKIP_LABELS" '
            [.[] | select(
              .labels as $labels |
              ($skip | split(",")) as $skipList |
              ($labels | map(.name) | map(. as $l | $skipList | map(. == $l) | any) | any) | not
            )]
          ')

          PR_COUNT=$(echo "$FILTERED_PRS" | jq 'length')
          echo "Found $PR_COUNT PRs to process"

          if [ "$PR_COUNT" -eq "0" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "### üìö gitlearn (weekly)" >> $GITHUB_STEP_SUMMARY
            echo "No new PRs to learn from this week." >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          echo "prs<<EOF" >> $GITHUB_OUTPUT
          echo "$FILTERED_PRS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Configure
        if: steps.skip.outputs.skip != 'true' && steps.collect.outputs.skip != 'true'
        run: |
          if [ -n "$GITLEARN_API_BASE" ]; then
            PROVIDER="custom"; API_KEY="${OPENAI_API_KEY:-${ANTHROPIC_API_KEY:-$OPENROUTER_API_KEY}}"
            MODEL="${GITLEARN_MODEL:-gpt-4o}"; THINKING=""
          elif [ -n "$ANTHROPIC_API_KEY" ]; then
            PROVIDER="anthropic"; API_KEY="$ANTHROPIC_API_KEY"
            MODEL="${GITLEARN_MODEL:-claude-sonnet-4-5-20250929}"; THINKING="${GITLEARN_THINKING_BUDGET:-10000}"
          elif [ -n "$OPENAI_API_KEY" ]; then
            PROVIDER="openai"; API_KEY="$OPENAI_API_KEY"
            MODEL="${GITLEARN_MODEL:-gpt-5.2-codex}"; THINKING=""
          elif [ -n "$OPENROUTER_API_KEY" ]; then
            PROVIDER="openrouter"; API_KEY="$OPENROUTER_API_KEY"
            MODEL="${GITLEARN_MODEL:-moonshotai/kimi-k2.5}"; THINKING=""
          else
            echo "::error::No API key. Add ANTHROPIC_API_KEY, OPENAI_API_KEY, or OPENROUTER_API_KEY"
            exit 1
          fi
          echo "PROVIDER=$PROVIDER" >> $GITHUB_ENV
          echo "MODEL=$MODEL" >> $GITHUB_ENV
          echo "THINKING=$THINKING" >> $GITHUB_ENV
          echo "MAX_TOKENS=${GITLEARN_MAX_TOKENS:-2048}" >> $GITHUB_ENV
          echo "::add-mask::$API_KEY"
          echo "API_KEY=$API_KEY" >> $GITHUB_ENV

      - name: Setup context files
        if: steps.skip.outputs.skip != 'true' && steps.collect.outputs.skip != 'true'
        id: setup
        run: |
          if [ ! -f claude.md ] && [ ! -f agents.md ]; then
            echo -e "# Project Context\n\n## Learnings" > claude.md
            ln -s claude.md agents.md
            echo "changes=true" >> $GITHUB_OUTPUT
          elif [ ! -f claude.md ] && [ -f agents.md ]; then
            mv agents.md claude.md && ln -s claude.md agents.md
            echo "changes=true" >> $GITHUB_OUTPUT
          elif [ -f agents.md ] && [ ! -L agents.md ]; then
            echo "merge=true" >> $GITHUB_OUTPUT
          elif [ ! -e agents.md ]; then
            ln -s claude.md agents.md
            echo "changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Merge existing files
        if: steps.skip.outputs.skip != 'true' && steps.collect.outputs.skip != 'true' && steps.setup.outputs.merge == 'true'
        run: |
          PROMPT="Merge these two AI context files into one. Remove duplicates, keep all unique information.

=== claude.md ===
$(cat claude.md)

=== agents.md ===
$(cat agents.md)

Output ONLY the merged markdown content."

          if [ "$PROVIDER" = "anthropic" ]; then
            REQUEST=$(jq -n --arg m "$MODEL" --arg p "$PROMPT" '{model:$m,max_tokens:8192,messages:[{role:"user",content:$p}]}')
            RESULT=$(curl -sf https://api.anthropic.com/v1/messages \
              -H "x-api-key: $API_KEY" -H "anthropic-version: 2023-06-01" -H "content-type: application/json" \
              -d "$REQUEST" | jq -r '.content | map(select(.type=="text")) | .[0].text // empty')
          else
            case "$PROVIDER" in
              openai) EP="https://api.openai.com/v1/chat/completions" ;;
              openrouter) EP="https://openrouter.ai/api/v1/chat/completions" ;;
              custom) EP="${GITLEARN_API_BASE}/chat/completions" ;;
            esac
            REQUEST=$(jq -n --arg m "$MODEL" --arg p "$PROMPT" '{model:$m,max_tokens:8192,messages:[{role:"user",content:$p}]}')
            RESULT=$(curl -sf "$EP" -H "Authorization: Bearer $API_KEY" -H "Content-Type: application/json" \
              -d "$REQUEST" | jq -r '.choices[0].message.content // empty')
          fi
          [ -n "$RESULT" ] && echo "$RESULT" > claude.md
          rm -f agents.md && ln -s claude.md agents.md

      - name: Generate learning (single PR)
        if: steps.skip.outputs.skip != 'true' && github.event_name == 'pull_request'
        id: learn
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get full existing context
          EXISTING_CLAUDE=""
          [ -f claude.md ] && EXISTING_CLAUDE=$(cat claude.md)

          PR_DIFF=$(gh pr diff ${{ github.event.pull_request.number }} --repo ${{ github.repository }} 2>/dev/null | head -c 15000 || echo "")

          PROMPT='You are an expert at extracting valuable learnings from code changes for AI coding assistants.

## Task
Analyze this merged PR and extract 1-3 lines of context that would help an AI assistant working on this codebase in the future.

## What makes a GOOD learning:
- Architectural decisions: "Uses event sourcing for order state"
- Non-obvious conventions: "All API routes must use zod validation middleware"
- Gotchas: "Redis keys expire after 24h - do not cache user sessions longer"
- Important patterns: "Background jobs use BullMQ, see src/jobs/"
- Integration details: "Stripe webhooks require signature verification in production"

## What to SKIP (output NONE):
- Obvious code changes (adding a button, fixing typos)
- Version bumps or dependency updates
- Test additions without architectural significance
- Refactoring that does not change behavior
- Documentation-only changes

## Format
Output a markdown snippet (1-3 lines, can include a ### header if starting new section).
Or output exactly: NONE

## Existing Context (DO NOT REPEAT)
'"$EXISTING_CLAUDE"'

## PR Details
Title: ${{ github.event.pull_request.title }}
Description: ${{ github.event.pull_request.body }}

## Code Changes
'"$PR_DIFF"

          if [ "$PROVIDER" = "anthropic" ]; then
            if [ -n "$THINKING" ] && [ "$THINKING" != "0" ]; then
              REQUEST=$(jq -n --arg m "$MODEL" --arg p "$PROMPT" --argjson t "$THINKING" \
                '{model:$m,max_tokens:16384,thinking:{type:"enabled",budget_tokens:$t},messages:[{role:"user",content:$p}]}')
            else
              REQUEST=$(jq -n --arg m "$MODEL" --arg p "$PROMPT" --argjson mt "$MAX_TOKENS" \
                '{model:$m,max_tokens:$mt,messages:[{role:"user",content:$p}]}')
            fi
            RESPONSE=$(curl -sf https://api.anthropic.com/v1/messages \
              -H "x-api-key: $API_KEY" -H "anthropic-version: 2023-06-01" -H "content-type: application/json" \
              -d "$REQUEST" 2>&1) || { echo "::error::API failed"; exit 1; }
            SUGGESTION=$(echo "$RESPONSE" | jq -r '.content | map(select(.type=="text")) | .[0].text // "NONE"')
          else
            case "$PROVIDER" in
              openai) ENDPOINT="https://api.openai.com/v1/chat/completions" ;;
              openrouter) ENDPOINT="https://openrouter.ai/api/v1/chat/completions" ;;
              custom) ENDPOINT="${GITLEARN_API_BASE}/chat/completions" ;;
            esac
            REQUEST=$(jq -n --arg m "$MODEL" --arg p "$PROMPT" --argjson mt "$MAX_TOKENS" \
              '{model:$m,max_tokens:$mt,messages:[{role:"user",content:$p}]}')
            RESPONSE=$(curl -sf "$ENDPOINT" \
              -H "Authorization: Bearer $API_KEY" -H "Content-Type: application/json" \
              -H "HTTP-Referer: https://github.com/${{ github.repository }}" \
              -d "$REQUEST" 2>&1) || { echo "::error::API failed"; exit 1; }
            SUGGESTION=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // "NONE"')
          fi

          [ -z "$SUGGESTION" ] && SUGGESTION="NONE"
          echo "suggestion<<EOF" >> $GITHUB_OUTPUT
          echo "$SUGGESTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate learning (weekly - process each PR)
        if: steps.skip.outputs.skip != 'true' && steps.collect.outputs.skip != 'true' && github.event_name != 'pull_request'
        id: learn_batch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Process each PR individually to maintain context-specific learnings
          PRS='${{ steps.collect.outputs.prs }}'
          PR_NUMBERS=""
          ALL_LEARNINGS=""
          PROCESSED=0

          # Limit to 5 most recent PRs
          RECENT_PRS=$(echo "$PRS" | jq -c '[.[] | select(.number != null)] | sort_by(.number) | reverse | .[0:5]')

          while read -r pr; do
            [ -z "$pr" ] && continue
            NUM=$(echo "$pr" | jq -r '.number')
            TITLE=$(echo "$pr" | jq -r '.title')
            BODY=$(echo "$pr" | jq -r '.body // ""' | head -c 1000)

            echo "Processing PR #$NUM: $TITLE"

            # Get diff for this specific PR
            PR_DIFF=$(gh pr diff "$NUM" --repo ${{ github.repository }} 2>/dev/null | head -c 15000 || echo "")

            [ -z "$PR_DIFF" ] && continue

            # Get current context (including any learnings added in this run)
            EXISTING_CLAUDE=""
            [ -f claude.md ] && EXISTING_CLAUDE=$(cat claude.md)
            EXISTING_CLAUDE="$EXISTING_CLAUDE$ALL_LEARNINGS"

            PROMPT='You are an expert at extracting valuable learnings from code changes for AI coding assistants.

## Task
Analyze this merged PR and extract 1-3 lines of context that would help an AI assistant working on this codebase in the future.

## What makes a GOOD learning:
- Architectural decisions: "Uses event sourcing for order state"
- Non-obvious conventions: "All API routes must use zod validation middleware"
- Gotchas: "Redis keys expire after 24h - do not cache user sessions longer"
- Important patterns: "Background jobs use BullMQ, see src/jobs/"
- Integration details: "Stripe webhooks require signature verification in production"

## What to SKIP (output NONE):
- Obvious code changes (adding a button, fixing typos)
- Version bumps or dependency updates
- Test additions without architectural significance
- Refactoring that does not change behavior
- Documentation-only changes

## Format
Output a markdown snippet (1-3 lines, can include a ### header if starting new section).
Or output exactly: NONE

## Existing Context (DO NOT REPEAT)
'"$EXISTING_CLAUDE"'

## PR Details
Title: '"$TITLE"'
Description: '"$BODY"'

## Code Changes
'"$PR_DIFF"

            if [ "$PROVIDER" = "anthropic" ]; then
              if [ -n "$THINKING" ] && [ "$THINKING" != "0" ]; then
                REQUEST=$(jq -n --arg m "$MODEL" --arg p "$PROMPT" --argjson t "$THINKING" \
                  '{model:$m,max_tokens:16384,thinking:{type:"enabled",budget_tokens:$t},messages:[{role:"user",content:$p}]}')
              else
                REQUEST=$(jq -n --arg m "$MODEL" --arg p "$PROMPT" --argjson mt "$MAX_TOKENS" \
                  '{model:$m,max_tokens:$mt,messages:[{role:"user",content:$p}]}')
              fi
              RESPONSE=$(curl -sf https://api.anthropic.com/v1/messages \
                -H "x-api-key: $API_KEY" -H "anthropic-version: 2023-06-01" -H "content-type: application/json" \
                -d "$REQUEST" 2>&1) || { echo "Warning: API failed for PR #$NUM"; continue; }
              SUGGESTION=$(echo "$RESPONSE" | jq -r '.content | map(select(.type=="text")) | .[0].text // "NONE"')
            else
              case "$PROVIDER" in
                openai) ENDPOINT="https://api.openai.com/v1/chat/completions" ;;
                openrouter) ENDPOINT="https://openrouter.ai/api/v1/chat/completions" ;;
                custom) ENDPOINT="${GITLEARN_API_BASE}/chat/completions" ;;
              esac
              REQUEST=$(jq -n --arg m "$MODEL" --arg p "$PROMPT" --argjson mt "$MAX_TOKENS" \
                '{model:$m,max_tokens:$mt,messages:[{role:"user",content:$p}]}')
              RESPONSE=$(curl -sf "$ENDPOINT" \
                -H "Authorization: Bearer $API_KEY" -H "Content-Type: application/json" \
                -H "HTTP-Referer: https://github.com/${{ github.repository }}" \
                -d "$REQUEST" 2>&1) || { echo "Warning: API failed for PR #$NUM"; continue; }
              SUGGESTION=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // "NONE"')
            fi

            # Skip if no meaningful learning
            if [ -n "$SUGGESTION" ] && [ "$SUGGESTION" != "NONE" ] && ! echo "$SUGGESTION" | grep -qi "^NONE"; then
              ALL_LEARNINGS="$ALL_LEARNINGS

<!-- PR #$NUM -->
$SUGGESTION"
              PR_NUMBERS="$PR_NUMBERS#$NUM "
              PROCESSED=$((PROCESSED + 1))
              echo "‚úì Extracted learning from PR #$NUM"
            else
              echo "‚è≠ No meaningful learning from PR #$NUM"
            fi

          done < <(echo "$RECENT_PRS" | jq -c '.[]')

          echo "pr_numbers=$PR_NUMBERS" >> $GITHUB_OUTPUT
          echo "processed=$PROCESSED" >> $GITHUB_OUTPUT

          if [ -z "$ALL_LEARNINGS" ]; then
            echo "suggestion=NONE" >> $GITHUB_OUTPUT
          else
            echo "suggestion<<EOF" >> $GITHUB_OUTPUT
            echo "$ALL_LEARNINGS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Update context PR (single PR)
        if: steps.skip.outputs.skip != 'true' && github.event_name == 'pull_request' && steps.learn.outputs.suggestion != 'NONE' && !contains(steps.learn.outputs.suggestion, 'NONE')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "gitlearn[bot]"
          git config user.email "gitlearn[bot]@users.noreply.github.com"

          # Find existing open gitlearn PR
          EXISTING_PR=$(gh pr list --state open --json number,headRefName --jq '.[] | select(.headRefName | startswith("gitlearn/")) | .headRefName' | head -1)

          if [ -n "$EXISTING_PR" ]; then
            # Append to existing PR branch
            BRANCH="$EXISTING_PR"
            git fetch origin "$BRANCH"
            git checkout "$BRANCH"
            git pull origin "$BRANCH" --rebase || git pull origin "$BRANCH"
          else
            # Create new branch with incrementing number
            LAST_NUM=$(git branch -r | grep -oE 'gitlearn/context-[0-9]+' | grep -oE '[0-9]+' | sort -n | tail -1)
            NEXT_NUM=$((${LAST_NUM:-0} + 1))
            BRANCH="gitlearn/context-$NEXT_NUM"
            git checkout -b "$BRANCH"
          fi

          # Apply setup changes if any
          [ "${{ steps.setup.outputs.changes }}" = "true" ] || [ "${{ steps.setup.outputs.merge }}" = "true" ] && git add claude.md agents.md 2>/dev/null || true

          # Append learning
          echo "" >> claude.md
          echo "<!-- PR #${{ github.event.pull_request.number }} -->" >> claude.md
          echo '${{ steps.learn.outputs.suggestion }}' >> claude.md

          git add claude.md agents.md
          git commit -m "üìö #${{ github.event.pull_request.number }}: ${{ github.event.pull_request.title }}" || exit 0

          # Push (retry with new branch if conflict)
          if ! git push origin "$BRANCH" 2>/dev/null; then
            LAST_NUM=$(git branch -r | grep -oE 'gitlearn/context-[0-9]+' | grep -oE '[0-9]+' | sort -n | tail -1)
            NEXT_NUM=$((${LAST_NUM:-0} + 1))
            NEW_BRANCH="gitlearn/context-$NEXT_NUM"
            git checkout -b "$NEW_BRANCH"
            git push origin "$NEW_BRANCH"
            BRANCH="$NEW_BRANCH"
          fi

          # Create PR if needed (with optional reviewer)
          if ! gh pr list --head "$BRANCH" --state open --json number | jq -e '.[0]' >/dev/null 2>&1; then
            REVIEWER_FLAG=""
            [ -n "$GITLEARN_REVIEWER" ] && REVIEWER_FLAG="--reviewer $GITLEARN_REVIEWER"
            gh pr create --title "ü§ñ Context Updates" \
              --body "Auto-accumulated learnings from merged PRs. Review and merge when ready." \
              --head "$BRANCH" --base main --label "gitlearn" $REVIEWER_FLAG 2>/dev/null || \
            gh pr create --title "ü§ñ Context Updates" --body "Accumulated learnings." --head "$BRANCH" --base main
          fi

          # Summary
          echo "### üìö gitlearn" >> $GITHUB_STEP_SUMMARY
          echo "**PR #${{ github.event.pull_request.number }}**: ${{ github.event.pull_request.title }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo '${{ steps.learn.outputs.suggestion }}' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Update context PR (weekly batch)
        if: steps.skip.outputs.skip != 'true' && steps.collect.outputs.skip != 'true' && github.event_name != 'pull_request' && steps.learn_batch.outputs.suggestion != 'NONE' && !contains(steps.learn_batch.outputs.suggestion, 'NONE')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "gitlearn[bot]"
          git config user.email "gitlearn[bot]@users.noreply.github.com"

          # Create new branch for weekly batch
          WEEK=$(date +%Y-W%V)
          BRANCH="gitlearn/weekly-$WEEK"

          # Check if branch already exists
          if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
            git fetch origin "$BRANCH"
            git checkout "$BRANCH"
            git pull origin "$BRANCH" --rebase || git pull origin "$BRANCH"
          else
            git checkout -b "$BRANCH"
          fi

          # Apply setup changes if any
          [ "${{ steps.setup.outputs.changes }}" = "true" ] || [ "${{ steps.setup.outputs.merge }}" = "true" ] && git add claude.md agents.md 2>/dev/null || true

          # Append learning with week marker
          echo "" >> claude.md
          echo "<!-- Weekly batch: $WEEK - PRs: ${{ steps.learn_batch.outputs.pr_numbers }} -->" >> claude.md
          echo '${{ steps.learn_batch.outputs.suggestion }}' >> claude.md

          git add claude.md agents.md
          git commit -m "üìö Weekly learnings: $WEEK" || exit 0

          # Push
          git push origin "$BRANCH" -u || git push origin "$BRANCH" --force-with-lease

          # Create or update PR with reviewer assignment
          REVIEWER_FLAG=""
          [ -n "$GITLEARN_REVIEWER" ] && REVIEWER_FLAG="--reviewer $GITLEARN_REVIEWER"

          if ! gh pr list --head "$BRANCH" --state open --json number | jq -e '.[0]' >/dev/null 2>&1; then
            gh pr create --title "ü§ñ Weekly Context Updates ($WEEK)" \
              --body "Weekly batch of learnings from merged PRs. Review and merge when ready.

**PRs included:** ${{ steps.learn_batch.outputs.pr_numbers }}" \
              --head "$BRANCH" --base main --label "gitlearn" $REVIEWER_FLAG 2>/dev/null || \
            gh pr create --title "ü§ñ Weekly Context Updates" --body "Weekly learnings batch." --head "$BRANCH" --base main
          else
            # Add reviewer to existing PR if configured
            if [ -n "$GITLEARN_REVIEWER" ]; then
              PR_NUM=$(gh pr list --head "$BRANCH" --state open --json number --jq '.[0].number')
              gh pr edit "$PR_NUM" --add-reviewer "$GITLEARN_REVIEWER" 2>/dev/null || true
            fi
          fi

          # Summary
          echo "### üìö gitlearn (weekly)" >> $GITHUB_STEP_SUMMARY
          echo "**Week:** $WEEK" >> $GITHUB_STEP_SUMMARY
          echo "**PRs processed:** ${{ steps.learn_batch.outputs.pr_numbers }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo '${{ steps.learn_batch.outputs.suggestion }}' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Summary (no learning - single PR)
        if: steps.skip.outputs.skip != 'true' && github.event_name == 'pull_request' && (steps.learn.outputs.suggestion == 'NONE' || contains(steps.learn.outputs.suggestion, 'NONE'))
        run: |
          echo "### üìö gitlearn" >> $GITHUB_STEP_SUMMARY
          echo "No meaningful learning from PR #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY

      - name: Summary (no learning - weekly)
        if: steps.skip.outputs.skip != 'true' && steps.collect.outputs.skip != 'true' && github.event_name != 'pull_request' && (steps.learn_batch.outputs.suggestion == 'NONE' || contains(steps.learn_batch.outputs.suggestion, 'NONE'))
        run: |
          echo "### üìö gitlearn (weekly)" >> $GITHUB_STEP_SUMMARY
          echo "No meaningful learnings extracted from this week's PRs." >> $GITHUB_STEP_SUMMARY
